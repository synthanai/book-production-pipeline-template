#!/bin/bash

# ============================================================================
# generate-pipeline-report.sh
# ============================================================================
#
# Creates a comprehensive human-readable status report of the entire pipeline.
#
# Usage:
#   ./generate-pipeline-report.sh [output-file]
#
# Examples:
#   ./generate-pipeline-report.sh                    # Print to stdout
#   ./generate-pipeline-report.sh status-report.md   # Save to file
#
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/config.sh"

cd "${PROJECT_ROOT}" || exit 1

OUTPUT_FILE=${1:-/dev/stdout}
TIMESTAMP=$(format_timestamp)

# Generate report
generate_report() {
cat <<EOF
# Pipeline Status Report

**Generated:** ${TIMESTAMP}
**Project:** ${PROJECT_NAME}

---

## Executive Summary

EOF

# Extract key metrics from metrics-summary.json
if [ -f "${PROJECT_ROOT}/${METRICS_SUMMARY}" ] && command -v jq &> /dev/null; then
  overall_completion=$(jq -r '.pipeline.overall_completion // 0' "${PROJECT_ROOT}/${METRICS_SUMMARY}")
  current_phase=$(jq -r '.pipeline.current_phase // 1' "${PROJECT_ROOT}/${METRICS_SUMMARY}")
  current_phase_name=$(jq -r '.pipeline.current_phase_name // "Ideation"' "${PROJECT_ROOT}/${METRICS_SUMMARY}")
  phases_complete=$(jq -r '.pipeline.phases_complete // 0' "${PROJECT_ROOT}/${METRICS_SUMMARY}")
  blocker=$(jq -r '.pipeline.critical_path_blocker // "None"' "${PROJECT_ROOT}/${METRICS_SUMMARY}")

cat <<EOF
- **Overall Progress:** ${overall_completion}% complete
- **Current Phase:** Phase ${current_phase} (${current_phase_name})
- **Phases Complete:** ${phases_complete}/${TOTAL_PHASES}
- **Critical Blocker:** ${blocker}

---

## Phase Status

EOF

  # Loop through all phases
  for phase in $(seq 1 $TOTAL_PHASES); do
    phase_name=$(get_phase_name $phase)
    phase_key="phase_${phase}"
    status=$(jq -r ".phases.${phase_key}.status // \"NOT_STARTED\"" "${PROJECT_ROOT}/${METRICS_SUMMARY}")
    completion=$(jq -r ".phases.${phase_key}.completion_percentage // 0" "${PROJECT_ROOT}/${METRICS_SUMMARY}")
    entry_gate=$(jq -r ".phases.${phase_key}.entry_gate_passed // false" "${PROJECT_ROOT}/${METRICS_SUMMARY}")
    exit_gate=$(jq -r ".phases.${phase_key}.exit_gate_passed // false" "${PROJECT_ROOT}/${METRICS_SUMMARY}")

    # Convert status to emoji
    case "$status" in
      COMPLETE) status_emoji="âœ…" ;;
      IN_PROGRESS) status_emoji="ðŸ”„" ;;
      BLOCKED) status_emoji="âŒ" ;;
      *) status_emoji="âšª" ;;
    esac

    # Gate status
    [ "$entry_gate" = "true" ] && entry_status="âœ…" || entry_status="â¸"
    [ "$exit_gate" = "true" ] && exit_status="âœ…" || exit_status="â¸"

cat <<EOF
### Phase ${phase}: ${phase_name}

- **Status:** ${status_emoji} ${status} (${completion}% complete)
- **Entry Gate:** ${entry_status} | **Exit Gate:** ${exit_status}

EOF
  done
else
  echo "Metrics data not available. Install 'jq' or check ${METRICS_SUMMARY}"
fi

cat <<EOF

---

## Quick Actions

**Check gate status:**
\`\`\`bash
./check-phase-gates.sh ${current_phase} exit
\`\`\`

**Get AI tasks:**
\`\`\`bash
./get-ai-tasks.sh ${current_phase}
\`\`\`

**Get manual tasks:**
\`\`\`bash
./get-manual-tasks.sh ${current_phase}
\`\`\`

---

## Related Documents

- [Pipeline Dashboard](../${PIPELINE_DASHBOARD})
- [Critical Path Tracker](../${CRITICAL_PATH_TRACKER})
- [Stage-Gate Reference](../${STAGE_GATES_REFERENCE})
- [Decision Log](../${DECISION_LOG})

---

*Report generated by generate-pipeline-report.sh*
EOF
}

# Generate and output report
if [ "$OUTPUT_FILE" = "/dev/stdout" ]; then
  generate_report
else
  generate_report > "$OUTPUT_FILE"
  echo "${EMOJI_SUCCESS} Report generated: $OUTPUT_FILE"
fi
